# DataStream的双流Join

## 一、实现机制

流Join和批Join的不同点在于批数据是“有界”的，而流数据是“无界”的，在“无界”的数据上做Join，我们首先要做的就是确定一个范围，从“无界”数据上找到一个“界”，然后让这个范围内的数据做Join。

在流数据中的“界”有两种，一种是**窗口**，包含滚动窗口、滑动窗口、事件窗口；一种是**间隔**，即a流中的数据要和b流哪些范围的数据做join。

Flink Join底层实现都是基于状态，它会把我们所定义的“界”内的数据保存到状态中，当这个“界”内的数据执行后，再清空状态。

## 二、基于窗口

### 2.1内连接

内连接是Flink内置的操作，我们可以直接用

```java
stream.join(otherStream)
    .where(<KeySelector>)
    .equalTo(<KeySelector>)
    .window(<WindowAssigner>) //窗口定义，这里可以用滚动窗口、滑动窗口、事件窗口
    .apply(<JoinFunction> / <FlatJoinFunction>);
```

一个具体事例：

```java
DataStream<Tuple2<String, Integer>> result =  stream1
        .join(stream2)
        .where(tuple -> tuple.f0)
        .equalTo(tuple -> tuple.f0)
        .window(TumblingEventTimeWindows.of(Time.seconds(1)))
        .apply( new JoinFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple2<String, Integer>>() {
                @Override
                public Tuple2<String, Integer> join(Tuple2<String, Integer> first, Tuple2<String, Integer> second) 
                  throws Exception {
                    return new Tuple2<>(first.f0, first.f1 + second.f1);
                }
            }
        );
```

**join的底层实现是用的coGroup实现的**，在调用JoinedStreams的apply方法时，会将JoinedStream转成CoGroupedStream，源码如下图：

![image-20230730175121622](https://raw.githubusercontent.com/MingRongXi/my-study-picture/master/image-20230730175121622.png)

在CoGroupedStream的apply方法中，会把两条流中**相同key**的数据放到两个ArrayList oneValues和twoValues中，然后再用**双层循环遍历这两个List，如果某一个List中没有元素，就会有一个循环进不去，导致数据发不出来，这样就实现了inner join**

源码如下：

![image-20230730180739402](https://raw.githubusercontent.com/MingRongXi/my-study-picture/master/image-20230730180739402.png)

![image-20230730180948380](https://raw.githubusercontent.com/MingRongXi/my-study-picture/master/image-20230730180948380.png)

#### 2.1.1 滚动窗口Join

![image-20230730165426849](https://raw.githubusercontent.com/MingRongXi/my-study-picture/master/image-20230730165426849.png)

#### 2.1.2 滑动窗口Join

![image-20230730182226420](https://raw.githubusercontent.com/MingRongXi/my-study-picture/master/image-20230730182226420.png)

#### 2.1.3 事件窗口Join

![image-20230730182259270](https://raw.githubusercontent.com/MingRongXi/my-study-picture/master/image-20230730182259270.png)

### 2.2外连接

Flink原生的sql语法只支持内连接，如果我们想实现外连接，用内连接的思路即可，即用cogroup实现，

```java
DataStream<Tuple3<String, Integer, Integer>> result =  stream1
        .coGroup(stream2)
        .where(tuple -> tuple.f0)
        .equalTo(tuple -> tuple.f0)
        .window(TumblingEventTimeWindows.of(Time.seconds(1)))
        .apply(new CoGroupFunction<Tuple2<String, Integer>, Tuple2<String, Integer>, Tuple3<String, Integer, Integer>>() {
               @Override
               public void coGroup(Iterable<Tuple2<String, Integer>> first, Iterable<Tuple2<String, Integer>> second, Collector<Tuple3<String, Integer, Integer>> out) throws Exception {
                   for(Tuple2<String, Integer> left: first) {
                       boolean flag = false;
                       for(Tuple2<String, Integer> right: second) {
                           flag = true;
                           out.collect(new Tuple3<>(left.f0, left.f1, right.f1));
                       }

                       if(!flag) {
                           out.collect(new Tuple3<>(left.f0, left.f1, null));
                       }

                   }
               }
           }
        );

```

## 基于Interval

内连接



外连接
